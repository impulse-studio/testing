---
alwaysApply: true
---

# Impulse Testing - E2E Testing Library Architecture

## Project Overview

Impulse Testing is an E2E testing library that opens applications locally and uses Puppeteer for testing user stories. The library operates in three distinct modes controlled by CLI arguments.

## Core Principles

1. **Ask Before Implementing**: For ALL technical decisions (libraries, frameworks, implementation approaches), you MUST ask the user for approval before proceeding. The only exceptions are the technologies explicitly defined in this document.
2. **Module Isolation**: Each module should be independent and communicate through well-defined interfaces.
3. **YAML-Based Storage**: All configuration and user stories are stored as YAML files in `.testing/` directory.
4. **Port 3303**: The Web UI always runs on port 3303 by default.

## Approved Technologies

The following technologies have been pre-approved:
- **Next.js**: For the Web UI module (running on port 3303)
- **Puppeteer**: For browser automation and recording
- **TypeScript**: For all source code
- **Node.js**: Runtime environment (>=18.0.0)

For ANY other technical decisions (validation libraries, CLI parsers, UI components, testing frameworks, etc.), you MUST ask the user before proceeding.

## Additional Approved Libraries

After user approval, the following have been added:
- **Commander**: CLI argument parsing and command handling
- **Zod**: Schema validation for configuration and stories
- **Execa**: Process management for starting/stopping tested apps
- **Chalk**: Terminal output coloring
- **@inquirer/prompts**: Interactive CLI prompts with arrow-key navigation
- **yaml**: YAML file parsing and writing

---

## Module Architecture

The library is composed of 4 main modules:

### 1. CLI Module (`src/cli/`) - ✅ IMPLEMENTED

**Status**: Completed and functional

**Responsibility**: Entry point that orchestrates all other modules based on command-line arguments.

**Core Functionality**:
- Parse command-line arguments
- Provide interactive shell for story management
- Route to appropriate mode (interactive, --ci, --new)
- Initialize configuration from `.testing/config.yml`
- Handle process lifecycle and graceful shutdown
- Manage error handling and exit codes

**CLI Arguments**:
```bash
$0              # Default mode: Interactive story selection
$0 --ci         # CI mode: Run all stories headlessly
$0 --new        # Recording mode: Create new user story
```

**Interactive Mode Features**:
- Lists all available stories from `.testing/stories/`
- Shows "Create new story" option at top
- Arrow-key navigation and selection
- Story creation onboarding (name, ID, start URL)
- Creates story files with minimal structure
- Integration points for recorder and runner modules

**Dependencies Used**:
- Commander for CLI framework
- @inquirer/prompts for interactive UI
- Chalk for colored output
- YAML for file operations

**Interface with other modules**:
- Calls **Web UI Module** in default mode (TODO)
- Calls **Testing Module** in `--ci` mode (TODO)
- Calls **Story Creator Module** in `--new` mode (TODO)

---

### 2. Testing Module (`src/runner/`) - TODO

**Responsibility**: Execute user stories from YAML files using Puppeteer in headless mode.

**Core Functionality**:
- Load user story YAML files from `.testing/stories/`
- Execute lifecycle commands (start app, setup database)
- Run Puppeteer in headless mode
- Execute each step's actions sequentially
- Validate assertions at each step
- Capture screenshots (based on config)
- Generate test reports
- Clean up resources (stop app, teardown database)

**Execution Flow**:
1. Read configuration from `.testing/config.yml`
2. Execute `appStartCommand` to start the tested application
3. Execute database `setupCommand` (if configured)
4. For each story file:
   - Load story YAML
   - Launch headless Puppeteer browser
   - Execute each step's actions
   - Validate each step's assertions
   - Capture screenshots (if configured)
   - Record step results (pass/fail)
5. Execute database `teardownCommand` (if configured)
6. Execute `appStopCommand` to stop the tested application
7. Generate final report (console, JSON, HTML)
8. Exit with appropriate code (0 = success, 1 = failure)

**Data Structures**:

**User Story File** (`.testing/stories/{story-id}/story.yml`):
```yaml
id: story-id
name: Story Name
start:
  url: http://localhost:3000
  resolution:
    width: 1920
    height: 1080
  pixelRatio: 1
  deviceScaleFactor: 1
actions:
  - type: click
    selector: "#button"
  - type: input
    selector: "#email"
    value: "test@example.com"
  - type: screenshot
    id: 0
```

**Action Types**:
- Navigation: `navigate`, `goBack`, `goForward`, `reload`
- Interaction: `click`, `input`, `select`, `check`, `uncheck`, `hover`, `focus`, `blur`
- Scrolling: `scroll`, `scrollIntoView`
- Wait: `wait`, `waitForSelector`, `waitForNavigation`
- File: `uploadFile`
- Advanced: `executeScript`, `screenshot`

**Assertion Types**:
- Element: `elementExists`, `elementNotExists`, `elementVisible`, `elementEnabled`, `elementChecked`
- Content: `textEquals`, `textContains`, `textMatches`, `valueEquals`, `attributeEquals`
- URL: `urlEquals`, `urlContains`, `urlMatches`
- Count: `elementCount`
- Page: `titleEquals`, `titleContains`

**Interface with other modules**:
- Can be invoked by **CLI Module** or **Web UI Module**
- Uses configuration loaded by **CLI Module**

---

### 3. Web UI Module (`src/webui/`) - TODO

**Responsibility**: Provide an interactive Next.js interface for managing user stories and viewing test results.

**Core Functionality**:
- Run Next.js server on port 3303
- List all user stories from `.testing/stories/`
- View individual story details (steps, actions, assertions)
- Display screenshots captured during tests
- Edit story steps, actions, and assertions
- Configure when screenshots are taken
- Trigger test execution (single story or all stories)
- Display real-time test execution progress
- Show test results and failure details
- Edit `.testing/config.yml` through UI

**Technology**:
- **Next.js App Router** (confirmed technology)
- Port: **3303** (fixed, non-configurable)

**UI Pages/Features**:
- Dashboard: Overview of all stories, recent test runs, statistics
- Stories List: Table/grid of all user stories with tags, status, last run
- Story Editor: Edit story metadata, steps, actions, assertions
- Story Viewer: View story execution with screenshots and results
- Configuration Editor: Edit `.testing/config.yml` through UI
- Test Runner: Trigger tests and show real-time progress
- Reports Viewer: View test reports and failure details

**Lifecycle**:
- **CLI Module** starts the Next.js server on port 3303
- Server manages its own lifecycle (auto-start/stop)
- Server process is terminated when CLI exits

**Interface with other modules**:
- Invoked by **CLI Module** in default mode
- Calls **Testing Module** to execute stories
- Reads/writes files managed by all modules

---

### 4. Story Creator Module (`src/recorder/`) - TODO

**Responsibility**: Open a controlled browser environment that records all user interactions and saves them as a user story.

**Core Functionality**:
- Launch Puppeteer in headed mode (visible browser)
- Navigate to configured application URL
- Inject event listeners to capture user interactions
- Record actions in sequence:
  - Mouse clicks (element, position, button)
  - Keyboard input (text, keystrokes)
  - Navigation (URL changes, back/forward)
  - Form interactions (select, checkbox, radio)
  - Scrolling
- Capture DOM state after each action
- Take screenshot after each action
- Generate unique, stable CSS selectors for elements
- Save complete user story to `.testing/stories/{generated-id}/story.yml`
- Save all screenshots to `.testing/screenshots/`

**Recording Flow**:
1. Read configuration from `.testing/config.yml`
2. Execute `appStartCommand` to start the tested application
3. Launch headed Puppeteer browser
4. Navigate to `appUrl` from config
5. Inject recording script into page
6. Capture all user events:
   - Click events → `click` actions
   - Input events → `input` actions
   - Navigation → `navigate` actions
   - Form changes → `select`, `check`, `uncheck` actions
7. For each captured event:
   - Generate stable CSS selector
   - Record action with selector, type, and value
   - Capture screenshot
   - Store DOM state metadata
8. When browser/tab closes:
   - Generate unique story ID
   - Save story YAML to `.testing/stories/{id}/story.yml`
   - Save all screenshots to `.testing/screenshots/{id}/`
9. Execute `appStopCommand` to stop the tested application

**Selector Generation**:
The recorder MUST generate stable, reliable CSS selectors:
- Priority 1: `id` attribute (if unique)
- Priority 2: `data-testid` or similar test attributes
- Priority 3: Combination of tag + classes + position
- Priority 4: XPath as fallback

**Important**:
- Recording happens in **headed** mode (browser visible)
- User performs actions naturally
- After recording, the story can be edited in **Web UI Module**
- Screenshots and actions can be customized post-recording

**Interface with other modules**:
- Invoked by **CLI Module** in `--new` mode
- Creates files that **Testing Module** and **Web UI Module** read

---

## File Structure

```
.testing/                           # User-facing configuration and data
├── config.yml                      # Main configuration file
├── stories/                        # User story directories
│   ├── login-flow-001/
│   │   └── story.yml
│   ├── checkout-flow-002/
│   │   └── story.yml
│   └── ...
└── screenshots/                    # Screenshots captured during tests/recording
    ├── login-flow-001/
    │   ├── 0.png
    │   ├── 1.png
    │   └── ...
    └── ...

src/cli/                            # CLI Module (IMPLEMENTED)
├── index.ts                        # Main entry point
├── interactive-mode.ts             # Interactive shell handler
├── list-stories.ts                 # Story listing logic
├── create-story.ts                 # Story creation workflow
└── utils/
    ├── slugify.ts                  # Slugification utility
    └── yaml-helper.ts              # YAML read/write helpers

src/runner/                         # Testing Module (TODO)
├── test-runner.ts                  # Main test execution engine
├── action-executor.ts              # Execute actions (click, input, etc.)
├── assertion-validator.ts          # Validate assertions
├── reporter.ts                     # Generate test reports
└── lifecycle.ts                    # App/DB lifecycle management

src/recorder/                       # Story Creator Module (TODO)
├── recorder.ts                     # Main recording orchestrator
├── event-listener.ts               # Browser event capture
├── selector-generator.ts           # Generate stable CSS selectors
└── dom-capture.ts                  # Capture DOM state and screenshots

src/webui/                          # Web UI Module (TODO)
├── app/                            # Next.js App Router
│   ├── page.tsx                    # Dashboard
│   ├── stories/                    # Story pages
│   │   ├── page.tsx                # Stories list
│   │   └── [id]/page.tsx           # Story detail/editor
│   └── api/                        # API routes
│       ├── stories/                # Story CRUD operations
│       ├── config/                 # Config read/write
│       └── run/                    # Trigger test execution
├── components/                     # React components
│   └── ...
└── lib/                            # Client-side utilities

src/core/                           # Shared utilities (TODO)
├── constants.ts                    # Constants (ports, paths, defaults)
├── config.ts                       # Config loading and validation
└── storage.ts                      # File system operations

src/types/                          # TypeScript type definitions (TODO)
└── index.ts                        # Shared types across modules
```

---

## Configuration File Structure

**Location**: `.testing/config.yml`

**Schema**:
```yaml
appStartCommand: npm run dev
appStopCommand: npm run stop
appUrl: http://localhost:3000
appPort: 3000
appReadyTimeout: 30000

database:
  setupCommand: npx prisma migrate deploy
  teardownCommand: npx prisma migrate reset --force
  seedCommand: npx prisma db seed
  resetBetweenTests: true

screenshotSettings:
  quality: 90
  format: png
  captureOnEveryStep: true
  captureOnFailure: true
  directory: .testing/screenshots

puppeteer:
  headless: true
  viewport:
    width: 1920
    height: 1080
  timeout: 30000
  slowMo: 0
  devtools: false
  args: []

testSettings:
  parallel: false
  retries: 0
  bail: false
  timeout: 60000

reporters:
  console: true
  json: false
  html: false
  outputDir: .testing/reports
```

**Notes**:
- The **Testing Module** uses this config to manage app/database lifecycle
- The **Story Creator Module** uses this config to know where to navigate
- The **Web UI Module** reads/writes this file through its API
- This file MUST be loaded and validated before any module executes

---

## Module Communication

```
┌─────────────────────────────────────────────────────────┐
│                      CLI Module                         │
│  (Entry point, orchestrates based on arguments)         │
└────┬──────────────────┬─────────────────┬──────────────┘
     │                  │                 │
     │ Default Mode     │ --ci Mode       │ --new Mode
     │                  │                 │
┌────▼─────────┐  ┌────▼──────────┐  ┌──▼───────────────┐
│  Web UI      │  │   Testing      │  │  Story Creator   │
│  Module      │  │   Module       │  │  Module          │
│              │  │                │  │                  │
│ - Next.js UI │  │ - Load stories │  │ - Launch browser │
│ - Port 3303  │  │ - Run tests    │  │ - Record events  │
│ - Story mgmt │  │ - Generate     │  │ - Save story     │
│ - Can invoke │  │   reports      │  │                  │
│   Testing    │  │                │  │                  │
│   Module     │  │                │  │                  │
└──────────────┘  └────────────────┘  └──────────────────┘
     │                  │                     │
     └──────────────────┼─────────────────────┘
                        │
            ┌───────────▼────────────┐
            │  Shared Storage Layer  │
            │                        │
            │  .testing/config.json  │
            │  .testing/stories/     │
            │  .testing/screenshots/ │
            └────────────────────────┘
```

---

## Implementation Guidelines

### When Creating New Code

1. **ASK FIRST**: Before implementing ANY new functionality, ask the user which technical approach/library/framework to use (except for pre-approved technologies listed above).

2. **Module Independence**: Each module should be self-contained and not directly import from other modules (except shared types and utilities).

3. **Error Handling**: All modules must handle errors gracefully and provide clear error messages.

4. **Validation**: All JSON files (config, stories) must be validated before use. Ask the user which validation library to use.

5. **Logging**: Implement consistent logging across all modules. Ask the user which logging approach/library to use.

6. **Testing**: Each module should be testable in isolation. Ask the user which testing framework to use.

### Constants to Use

Create a `src/core/constants.ts` file with:
```typescript
export const WEBUI_PORT = 3303;
export const TESTING_DIR = '.testing';
export const CONFIG_FILE = '.testing/config.yml';
export const STORIES_DIR = '.testing/stories';
export const SCREENSHOTS_DIR = '.testing/screenshots';
export const STORY_FILE = 'story.yml';
```

### File Naming Conventions

- Story directories: `{story-id}/` (e.g., `login-flow-001/`)
- Story files: `story.yml` inside each story directory
- Screenshots: `{screenshot-id}.png` (e.g., `0.png`, `1.png`)
- Reports: `{timestamp}-report.json` or `{timestamp}-report.html`

---

## Development Workflow

1. **Initialize Project**: User runs `$0 init` to create `.testing/` directory and default `config.json`
2. **Record Stories**: User runs `$0 --new` to create user stories
3. **Edit Stories**: User runs `$0` (Web UI) to edit/refine stories
4. **Run Tests Locally**: User runs `$0` (Web UI) to execute tests and see results
5. **Run Tests in CI**: User runs `$0 --ci` in CI pipeline

---

## Key Design Decisions

1. **YAML Storage**: Human-readable, version-controllable, no database dependency
2. **Port 3303**: Fixed port for Web UI to avoid conflicts
3. **Separate Stories Directory**: Each story is a separate file for easy version control
4. **Post-Recording Editing**: Recording creates raw data, Web UI allows refinement
5. **Headless vs Headed**: Recording is headed, testing/CI is headless
6. **Screenshot Auto-Capture**: Screenshots captured automatically but configurable
7. **Lifecycle Management**: Library handles app/database lifecycle completely

---

## Important Reminders

- ✅ **Next.js** is approved for Web UI Module
- ✅ **Puppeteer** is approved for browser automation
- ✅ **TypeScript** is approved for all code
- ✅ **Port 3303** is fixed for Web UI
- ❌ For EVERYTHING ELSE (validation libs, CLI parsers, UI components, state management, etc.), **ASK THE USER FIRST**
- 🔄 All modules read/write to `.testing/` directory
- 🔄 Config file `.testing/config.json` is the single source of truth for configuration
- 🔄 The tested application's lifecycle (start/stop/database) is managed by the library based on config

---

## Questions to Ask Before Implementation

Before implementing any part of the system, ask the user:

1. **CLI Parsing**: Which library/approach for CLI argument parsing? (commander, yargs, native, etc.)
2. **Validation**: Which library for validating JSON schemas? (zod, joi, ajv, etc.)
3. **File System**: Use native fs or a library? (fs-extra, etc.)
4. **Logging**: Which logging approach? (console, winston, pino, etc.)
5. **Process Management**: How to spawn/manage app processes? (child_process, execa, etc.)
6. **UI Components**: Which component library for Web UI? (shadcn, MUI, custom, etc.)
7. **State Management**: How to manage state in Web UI? (React state, Zustand, Redux, etc.)
8. **Styling**: How to style Web UI? (Tailwind, CSS Modules, styled-components, etc.)
9. **Testing**: Which testing framework? (Jest, Vitest, etc.)
10. **Build Tool**: Which build tool? (tsup, esbuild, webpack, etc.)

---

## Summary

This testing library consists of 4 independent modules orchestrated by a CLI entry point:

1. **CLI Module**: Routes to appropriate mode
2. **Testing Module**: Executes user stories headlessly in CI
3. **Web UI Module**: Manages stories and displays results (Next.js on port 3303)
4. **Story Creator Module**: Records user interactions into story files

All data is stored in `.testing/` directory with YAML files. The library manages the complete lifecycle of the tested application including database setup/teardown.

**ALWAYS ask the user before making technical implementation decisions beyond the pre-approved technologies.**
