---
description: Recorder Module Implementation Details
---

# Recorder Module Implementation

## Overview

The recorder module is responsible for capturing user interactions in a headed browser and saving them as test stories. It integrates with the CLI to provide an interactive recording experience.

## Module Status

✅ **FULLY IMPLEMENTED**

## Architecture

The recorder module consists of several components working together to capture, process, and save user interactions:

### Core Infrastructure (src/core/)

Shared utilities used by recorder, runner, and webui modules:

- **constants.ts**: Project-wide constants (ports, paths, file names)
- **types.ts**: TypeScript type definitions for Config, Story, Actions
- **config-loader.ts**: Loads and validates config.yml using Zod schemas
- **start-app.ts**: Starts the application using lifecycle commands
- **stop-app.ts**: Stops the application and executes cleanup commands
- **utils/execute-command.ts**: Executes individual lifecycle commands using Execa

### Recorder Components (src/recorder/)

- **index.ts**: Main orchestrator that coordinates all components
- **browser-manager.ts**: Launches Puppeteer in headed mode with story configuration
- **event-capture.ts**: Captures DOM events and converts to Action objects
- **selector-generator.ts**: Generates stable CSS selectors (id → data-testid → complex)
- **screenshot-manager.ts**: Captures and saves screenshots to .testing/screenshots
- **story-updater.ts**: Reads and appends actions to story.yml files
- **recording-ui.ts**: Injects floating UI with Stop/Snapshot buttons into the page

## Key Features

### 1. Selector Generation Priority

The selector-generator uses a three-tier priority system:

1. **ID attribute** - If unique, uses `#id`
2. **data-testid** - Uses `[data-testid="value"]`
3. **data-test** - Uses `[data-test="value"]`
4. **Complex selector** - Generated using css-selector-generator library

Each selector is validated for uniqueness before being used.

### 2. Event Capture

Captures the following DOM events and converts them to actions:

- **Clicks** → ClickAction
- **Text input** → InputAction (tracked and grouped until snapshot)
- **Select changes** → SelectAction
- **Checkbox** → CheckAction/UncheckAction
- **Radio buttons** → CheckAction/UncheckAction
- **Navigation** → NavigateAction (detected automatically via framenavigated)

### 3. Input Grouping Strategy

Input events use a special tracking system:

- Input events are stored in a Map (selector → value)
- Only the final value for each input is retained
- Inputs are flushed to actions when:
  - User clicks "Take Snapshot" button
  - Recording stops
  - Browser closes

This ensures inputs are split at snapshot boundaries as required by the architecture.

### 4. Screenshot Management

Screenshots are captured using Puppeteer's screenshot API:

- Screenshots are only taken when user clicks "Take Snapshot" button
- Saved to `.testing/screenshots/{storyId}/{id}.png`
- Screenshot IDs auto-increment starting from 0
- Each snapshot creates a screenshot action in story.yml
- Viewport-only (not full page) screenshots
- **Recording UI is automatically hidden** during screenshot capture and restored immediately after to ensure clean screenshots

### 5. Recording UI

A floating draggable panel is injected into the page with:

- **Container ID**: `__impulse-testing__ui` - Used for event filtering and UI management
- **Take Snapshot** button (blue) - captures current state and screenshot
- **Stop Recording** button (red) - ends recording and saves
- **Drag handle** - allows repositioning the panel
- Positioned at bottom center by default
- Styled with modern CSS (glassmorphism, shadows, hover effects, rounded corners)
- High z-index to stay on top of page content
- **Event filtering**: All interactions with the UI container (`#__impulse-testing__ui`) are automatically filtered out and not recorded as test actions

### 6. Browser-Side Injected Code Structure

For better IDE support and maintainability, all browser-side JavaScript code is stored in separate files:

**Location**: `src/recorder/injected/`

- **event-capture-client.js** - Pure browser JavaScript for event capture
  - Contains inline selector generation logic
  - Attaches click, input, and change event listeners
  - Filters out impulse UI elements using `isImpulseUI()` helper that checks for `#__impulse-testing__ui`
  - Communicates events via window.__impulse_captureEvent()

- **recording-ui-client.js** - Pure browser JavaScript for recording UI
  - Creates the floating recording panel HTML
  - Injects CSS styles
  - Attaches button event handlers
  - Implements drag-and-drop functionality
  - Communicates via window.__impulse_onStop() and window.__impulse_onSnapshot()

These files are **pure browser JavaScript** with:
- No imports or require statements
- No TypeScript syntax
- No Node.js APIs
- Full IDE IntelliSense support

The TypeScript files (`event-capture.ts` and `recording-ui.ts`) load these files at runtime using `fs.readFileSync()` with `import.meta.url` for path resolution.

**Benefits:**
- ✅ Full JavaScript IntelliSense when editing injected code
- ✅ Better syntax highlighting and error detection
- ✅ Easier to maintain and debug
- ✅ Cleaner separation between Node.js and browser code
- ✅ Changes are picked up at runtime without recompilation

### 7. Auto-Save on Exit

Recording automatically saves pending actions when:

- User closes the browser window (via 'disconnected' event)
- User clicks "Stop Recording" button
- Browser crashes or connection is lost

This ensures no user interactions are lost.

### 8. Event Injection Strategy

Uses a dual-injection approach for persistence:

- `page.evaluateOnNewDocument()` - Ensures listeners are injected on all future navigations
- `injectListeners()` - Manually injects listeners on current page after initial load
- Event listeners persist across navigation automatically
- Filters out impulse UI elements using `isImpulseUI()` helper that checks for `#__impulse-testing__ui` container

## Integration Points

### CLI Integration

The recorder is invoked by the CLI's create-new-story callback:

1. User runs interactive mode
2. Selects "Create new story"
3. Provides story name, ID, and start URL
4. CLI creates story.yml with metadata and empty actions array
5. CLI invokes `startRecording(storyId)`
6. Recorder launches and user performs actions
7. Actions are appended to the created story.yml

### Configuration Requirements

Requires `.testing/config.yml` to exist with:

```yaml
lifecycle:
  start:
    - command: npm run dev
      keepAlive: true
      timeout: 30000
  stop:
    - command: pkill -f "npm run dev"
```

The recorder:

1. Loads config using config-loader
2. Starts app using lifecycle-manager
3. Records user actions
4. Stops app on completion

## Dependencies Used

### Approved Libraries

- **Puppeteer**: Browser automation (headed mode for recording)
- **Execa**: Process management for app lifecycle
- **Zod**: Config validation and type safety
- **YAML**: Story file reading/writing
- **Chalk**: Terminal output coloring

### New Dependencies

- **css-selector-generator**: Generates complex CSS selectors as fallback

## File Structure

```
src/core/                      # Shared utilities
├── constants.ts               # Project constants
├── types.ts                   # TypeScript types
├── config-loader.ts           # Config loading with Zod
├── start-app.ts               # App startup lifecycle
├── stop-app.ts                # App shutdown lifecycle
└── utils/
    └── execute-command.ts     # Command execution with Execa

src/recorder/                  # Recorder module
├── index.ts                   # Main orchestrator
├── browser-manager.ts         # Puppeteer browser launch
├── event-capture.ts           # Event tracking system (loads injected code)
├── selector-generator.ts      # Selector generation
├── screenshot-manager.ts      # Screenshot capture
├── recording-ui.ts            # Injected UI (loads injected code)
├── story-updater.ts           # Story file updates
└── injected/                  # Browser-side JavaScript
    ├── event-capture-client.js    # Event capture logic
    └── recording-ui-client.js     # Recording UI implementation

src/cli/callbacks/create-new-story/
├── handler.ts                 # Invokes recorder.startRecording()
└── create-story.ts            # Story onboarding flow
```

## Technical Details

### Browser Configuration

Launched with the following settings:

- `headless: false` - Visible browser for user interaction
- `defaultViewport` from story.start.resolution (default 1920x1080)
- `deviceScaleFactor` from story config
- `pixelRatio` applied via setViewport if needed
- `waitUntil: 'networkidle2'` for initial navigation

### Event Communication

Uses Puppeteer's `exposeFunction` API to communicate events:

- `page.exposeFunction('__impulse_captureEvent', handler)` - Receives DOM events
- `page.exposeFunction('__impulse_onStop', callback)` - Stop button handler
- `page.exposeFunction('__impulse_onSnapshot', callback)` - Snapshot button handler
- Events are sent from page context to Node.js via these exposed functions

### Story File Updates

Actions are appended to existing story.yml:

1. Load current story using `loadStory(storyId)`
2. Append new actions to actions array: `story.actions = [...story.actions, ...actions]`
3. Write back using `writeYamlFile()` preserving all metadata (id, name, start)

### Selector Generation in Browser Context

The selector generation logic exists in two places:

1. **selector-generator.ts** - Node.js version (currently unused, may be used by runner module)
2. **injected/event-capture-client.js** - Browser version for runtime generation

The browser version is embedded in the injected event capture code to:
- Avoid serialization issues with passing Element objects
- Generate selectors immediately when events fire
- Keep the logic colocated with event handling

Both implementations follow the same priority: id → data-testid → data-test → complex path-based selector.

## Error Handling

The recorder implements comprehensive error handling:

- Validates config.yml exists before starting
- Cleans up resources (browser, app) on errors
- Auto-saves actions before exit even on errors
- Clear error messages with colored output (chalk)
- Graceful degradation for selector generation failures
- Process cleanup in try-catch blocks

## Recording Flow

### Initialization Phase

1. Load config from config.yml
2. Load story metadata from story.yml
3. Start app using lifecycle manager
4. Launch headed browser with story configuration
5. Create EventCapture instance
6. Start capturing events
7. Inject recording UI with callbacks
8. Display success message

### Recording Phase

User interacts naturally with the application while:

- Click events → Added to pendingActions immediately
- Input events → Tracked in inputTracking Map
- Select/checkbox/radio changes → Added to pendingActions immediately
- Navigation → Detected automatically and added to pendingActions

### Snapshot Phase

When user clicks "Take Snapshot":

1. Flush all tracked inputs to actions
2. Add screenshot action with current ID
3. Take actual screenshot and save to disk
4. Append all pending actions to story.yml
5. Clear pendingActions array
6. Increment screenshot counter
7. Display success message

### Termination Phase

When user clicks "Stop Recording" or closes browser:

1. Get any remaining pending actions
2. Flush input tracking
3. Append pending actions to story.yml if any exist
4. Remove recording UI from page
5. Close browser
6. Stop app using lifecycle manager
7. Display completion message

## Usage

### From CLI

```bash
$0              # Interactive mode
> Create new story
> Enter name: "User Login Flow"
> Enter ID: user-login-flow
> Enter URL: http://localhost:3000
> Browser opens, record actions
> Click "Take Snapshot" after each logical step
> Click "Stop Recording" when done
```

### Programmatic Usage

```typescript
import { startRecording } from './recorder';

await startRecording('my-story-id');
```

## Code Principles

### Naming and Structure

- Use kebab-casing for all filenames
- Function names should be explicit and self-documenting
- Variable names should clearly indicate their purpose
- Avoid unnecessary comments - code should be readable

### Modularity

- Each file handles a single responsibility
- Components are loosely coupled
- Communication happens through well-defined interfaces
- Shared utilities extracted to src/core/

### Simplicity

- Implement only what's needed now
- Don't over-engineer for future requirements
- Keep complexity minimal
- Refactoring happens when new features are added

## Future Enhancements

The following are NOT yet implemented:

- Smart wait detection (runner module feature)
- Screenshot comparison (runner module feature)
- Edit mode for existing stories (webui module feature)
- Assertion generation (may be added to recorder or webui)
- Advanced selector strategies (XPath, custom attributes)
- Screenshot diffing during recording
- Undo/redo functionality
- Pause/resume recording
- Action editing during recording

## Known Limitations

1. **Selector generation** runs in browser context via injected/event-capture-client.js, so the selector-generator.ts file is currently unused
2. **Input grouping** doesn't split inputs mid-typing (only at snapshots)
3. **Navigation events** are detected but don't trigger automatic snapshots
4. **Iframes** are not currently supported
5. **Shadow DOM** elements may not be captured correctly
6. **File uploads** are captured as click events, not upload actions

## Summary

The recorder module provides a complete user interaction recording system that:

- Opens visible browser for natural user interaction
- Captures clicks, inputs, form changes, navigation
- Groups actions by snapshot boundaries
- Generates stable, unique selectors
- Saves to YAML format with clean structure
- Integrates seamlessly with CLI workflow
- Handles errors gracefully with proper cleanup
- Auto-saves on unexpected exits

The implementation is production-ready and follows all architectural guidelines defined in the impulse-testing-architecture document.
